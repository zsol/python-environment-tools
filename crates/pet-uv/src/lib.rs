use std::{
    fs,
    path::{Path, PathBuf},
    sync::{Arc, Mutex},
};

use log::trace;
use pet_core::{
    env::PythonEnv,
    python_environment::{PythonEnvironment, PythonEnvironmentBuilder, PythonEnvironmentKind},
    pyvenv_cfg::PyVenvCfg,
    reporter::Reporter,
    Configuration, Locator, LocatorKind,
};
use pet_python_utils::executable::find_executables;
use serde::Deserialize;
pub struct Uv {
    pub workspace_directories: Arc<Mutex<Vec<PathBuf>>>,
}

/// Represents information stored in a `pyvenv.cfg` generated by uv
struct UvVenv {
    uv_version: String,
    python_version: String,
    prompt: String,
}

impl UvVenv {
    fn maybe_from_file(file: &Path) -> Option<Self> {
        let contents = fs::read_to_string(file).ok()?;
        let mut uv_version = None;
        let mut python_version = None;
        let mut prompt = None;
        for line in contents.lines() {
            if let Some(uv_version_value) = line.trim_start().strip_prefix("uv = ") {
                uv_version = Some(uv_version_value.trim_end().to_string())
            }
            if let Some(version_info) = line.trim_start().strip_prefix("version_info = ") {
                python_version = Some(version_info.to_string());
            }
            if let Some(prompt_value) = line.trim_start().strip_prefix("prompt = ") {
                prompt = Some(prompt_value.trim_end().to_string());
            }
        }
        Some(Self {
            uv_version: uv_version?,
            python_version: python_version?,
            prompt: prompt?,
        })
    }
}

impl Uv {
    pub fn new() -> Self {
        Self {
            workspace_directories: Arc::new(Mutex::new(Vec::new())),
        }
    }
}

impl Locator for Uv {
    fn get_kind(&self) -> LocatorKind {
        LocatorKind::Uv
    }

    fn supported_categories(&self) -> Vec<PythonEnvironmentKind> {
        vec![
            PythonEnvironmentKind::Uv,
            PythonEnvironmentKind::UvWorkspace,
        ]
    }

    fn configure(&self, config: &Configuration) {
        if let Some(workspace_directories) = config.workspace_directories.as_ref() {
            let mut ws = self.workspace_directories.lock().unwrap();
            ws.clear();
            ws.extend(workspace_directories.iter().cloned());
        }
    }

    fn try_from(&self, env: &PythonEnv) -> Option<PythonEnvironment> {
        let cfg = env
            .executable
            .parent()
            .and_then(|parent| PyVenvCfg::find(parent))
            .or_else(|| {
                env.prefix
                    .as_ref()
                    .and_then(|prefix| PyVenvCfg::find(&prefix))
            })?;
        let uv_venv = UvVenv::maybe_from_file(&cfg.file_path)?;
        trace!(
            "uv-managed venv found in {}, made by uv {}",
            env.executable.display(),
            uv_venv.uv_version
        );
        let prefix = env.prefix.clone().or_else(|| {
            env.executable
                .parent()
                .and_then(|p| p.parent().map(|pp| pp.to_path_buf()))
        });
        let pyproject = prefix
            .as_ref()
            .and_then(|prefix| prefix.parent())
            .and_then(|parent| parse_pyproject_toml_in(parent));
        let kind = if pyproject
            .and_then(|pyproject| pyproject.tool)
            .and_then(|t| t.uv)
            .and_then(|uv| uv.workspace)
            .is_some()
        {
            PythonEnvironmentKind::UvWorkspace
        } else {
            PythonEnvironmentKind::Uv
        };

        Some(
            PythonEnvironmentBuilder::new(Some(kind))
                .name(Some(uv_venv.prompt))
                .executable(Some(env.executable.clone()))
                .version(Some(uv_venv.python_version))
                .symlinks(prefix.as_ref().map(|p| find_executables(p)))
                .prefix(prefix)
                .build(),
        )
    }

    fn find(&self, reporter: &dyn Reporter) {
        // look through workspace directories for uv-managed projects and any of their workspaces
        let workspaces = self.workspace_directories.lock().unwrap().clone();
        for workspace in workspaces {
            // TODO: maybe check for workspace in parent folders?
            for env in list_envs_in_directory(&workspace) {
                reporter.report_environment(&env);
            }
        }
    }
}

fn find_workspace(path: &Path) -> Option<PythonEnvironment> {
    for candidate in path.ancestors() {
        let pyproject = parse_pyproject_toml_in(&candidate);
        if pyproject
            .as_ref()
            .and_then(|pp| pp.tool.as_ref())
            .and_then(|tool| tool.uv.as_ref())
            .and_then(|uv| uv.workspace.as_ref())
            .is_none()
        {
            continue;
        }
        // TODO: check for workspace members/excludes
        trace!("Found workspace at {:?}", candidate);
        let prefix = candidate.join(".venv");
        let pyvenv_cfg = prefix.join("pyvenv.cfg");
        if !pyvenv_cfg.exists() {
            trace!(
                "Workspace at {} does not have a virtual environment",
                candidate.display()
            );
            return None;
        }
        let unix_executable = prefix.join("bin/python");
        let windows_executable = prefix.join("Scripts/python.exe");
        let executable = if unix_executable.exists() {
            Some(unix_executable)
        } else if windows_executable.exists() {
            Some(windows_executable)
        } else {
            None
        };
        if let Some(uv_venv) = UvVenv::maybe_from_file(&pyvenv_cfg) {
            return Some(
                PythonEnvironmentBuilder::new(Some(PythonEnvironmentKind::UvWorkspace))
                    .name(Some(uv_venv.prompt))
                    .executable(executable)
                    .version(Some(uv_venv.python_version))
                    .symlinks(Some(find_executables(&prefix)))
                    .prefix(Some(prefix))
                    .build(),
            );
        } else {
            trace!(
                "Workspace at {} does not have a uv-managed virtual environment",
                candidate.display()
            );
        }
        return None;
    }
    None
}

fn list_envs_in_directory(path: &Path) -> Vec<PythonEnvironment> {
    let mut envs = Vec::new();
    let pyproject = parse_pyproject_toml_in(&path);
    if pyproject.is_none() {
        return envs;
    }
    let pyproject = pyproject.unwrap();
    let pyvenv_cfg = path.join(".venv/pyvenv.cfg");
    let prefix = path.join(".venv");
    let unix_executable = prefix.join("bin/python");
    let windows_executable = prefix.join("Scripts/python.exe");
    let executable = if unix_executable.exists() {
        Some(unix_executable)
    } else if windows_executable.exists() {
        Some(windows_executable)
    } else {
        None
    };
    if pyproject
        .tool
        .and_then(|t| t.uv)
        .and_then(|uv| uv.workspace)
        .is_some()
    {
        trace!("Workspace found in {}", path.display());
        let pyvenv_cfg = path.join(".venv/pyvenv.cfg");
        if let Some(uv_venv) = UvVenv::maybe_from_file(&pyvenv_cfg) {
            trace!("uv-managed venv found for workspace in {}", path.display());
            let env = PythonEnvironmentBuilder::new(Some(PythonEnvironmentKind::UvWorkspace))
                .name(Some(uv_venv.prompt))
                .symlinks(Some(find_executables(&prefix)))
                .prefix(Some(prefix))
                .executable(executable)
                .version(Some(uv_venv.python_version))
                .build();
            envs.push(env);
        } else {
            trace!(
                "No uv-managed venv found for workspace in {}",
                path.display()
            );
        }
    // prioritize the workspace over the project if it's the same venv
    } else if let Some(project) = pyproject.project {
        if let Some(uv_venv) = UvVenv::maybe_from_file(&pyvenv_cfg) {
            trace!("uv-managed venv found for project in {}", path.display());
            let env = PythonEnvironmentBuilder::new(Some(PythonEnvironmentKind::Uv))
                .name(Some(uv_venv.prompt))
                .symlinks(Some(find_executables(&prefix)))
                .prefix(Some(prefix))
                .version(Some(uv_venv.python_version))
                .display_name(project.name)
                .executable(executable)
                .build();
            envs.push(env);
        } else {
            trace!("No uv-managed venv found in {}", path.display());
        }
        if let Some(workspace) = path.parent().and_then(|p| find_workspace(p)) {
            envs.push(workspace);
        }
    }

    envs
}

fn parse_pyproject_toml_in(path: &Path) -> Option<PyProjectToml> {
    let contents = fs::read_to_string(path.join("pyproject.toml")).ok()?;
    toml::from_str(&contents).ok()
}

#[derive(Deserialize, Debug)]
struct PyProjectToml {
    project: Option<Project>,
    tool: Option<Tool>,
}

#[derive(Deserialize, Debug)]
struct Project {
    name: Option<String>,
}

#[derive(Deserialize, Debug)]
struct Tool {
    uv: Option<ToolUv>,
}

#[derive(Deserialize, Debug)]
struct ToolUv {
    workspace: Option<serde::de::IgnoredAny>,
}

#[cfg(test)]
mod tests {
    use super::*;
}
